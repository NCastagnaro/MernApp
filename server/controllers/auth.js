import bcrypt from "bcrypt" //This allows us to encrypt our password
import jwt from "jsonwebtoken" //A way to send a user a web token so that they can use for authorization 
import User from "../models/User.js" //A reference to our User.js file inside our models controller. This references our User model

/*Register User==============================================================================*/
//we need this to be async because we will be calling our mongo database. 
//It is essentially like an API call that you do from frontend to backend, then backend to a database
export const register = async (req, res) => {   //req will provide us with the request body that we get from the frontend. And the response is what we will be sending back to the frontend. 
    try{
        //We will be destructing these parameters from the req.body. So, on the frontend, we will have to send an object that has these parameters. Typically it is submitted in a form. 
        const{
            firstName,
            lastName,
            email,
            password,
            picturePath,
            friends,
            location,
            occupation
        } = req.body

        const salt = await bcrypt.genSalt() //Whwt this does is creates a random salt provided by brypt. This salt variable we created is used to enrypt our password  
        const passwordHash = await bcrypt.hash(password, salt)  //to encrypt our passwords, we can create a 'salt' and pass it in and hash it together. 
        
        //The way this register function works is that we encrypt the password, we are going to save it and then after we save it when the user tries to log in, they are going to provide the password,
        // we are going to salt that again and we're going to make sure it's the correct one and we are going to give them a JSON web token.
        const newUser = new User({
            firstName,
            lastName,
            email,
            password:passwordHash,          //We are storing the passwordHash in there, rather than the actual password
            picturePath,
            friends,
            location,
            occupation,
            viewedProfile: Math.floor(Math.random() * 10000),       //We give a random viewedProfile value between 1 and 10,000
            impressions: Math.floor(Math.random() * 10000)        //We give a random viewedProfile value between 1 and 10,000
        })
        const savedUser = await newUser.save()                      //We are sending back the exact savedUser value in the correct format, and the frontend will use the same format as well.
                                                                    //If you have the same naming conventions, you can use the same exact data that's being sent from the backend. Otherwise, you are going to have to find ways to write code that will convert it 
        res.status(201).json(savedUser)                             //If there are no errors, we will send the user back a status code of 201, which signifies that something was created. We create a JSON version of the savedUser so that the frontend can receive this response.

    }catch(err){
        res.status(500).json({error:err.message})                                      //When something goes wrong, we will send the frontend a status code of 500
    }
}

/*Logging in*/

export const login = async (req,res) => {
    try{
        const{email,password} = req.body                    //we grab the email and password when the user tries to login
        const user = await User.findOne({email:email})      //We use Mongoose to try to find the document that has this specified email. And we assign that document from our database to a "user" variable
        if(!user) return res.status(400).json({msg:"User does not exist"})      //If "user" variable doesn't exist, we know there is no document in our database that mathed that info. Therefore, we will return a message that the "User does not exist"
        
        const  isMatch = await bcrypt.compare(password, user.password) //This determines if we match passwords. We use bcrypt to compare the password the user sent and the user.password that was saved inside the database. They both use the same salt to compare whether or not they have the same hash or not
        if(!isMatch) return res.status(400).json({msg:"Invalid credentials"})   //If the "isMatch" variable is non existent, then we know we have invalid credentials entered by the user

        const token = jwt.sign({id:user._id},process.env.JWT_SECRET)    //The variable we created, "token" will store the JWT generated by jwt.sign(). jwt.sign() is a method provided by the "jsonwebtoken" library that reates a JWT based on a payload and a secret key. The payload is an objet that ontains information about the user that will be included in the JWT. In this case, the payload is "{id:user._id}" which is an object containing the user's ID. The "user._id" is a unique identifier that is used to look up a user's info in a database. 
        //"proccess.env.JWT_SECRET" is the secret key that is used to sign the JWT. It is stored in an env file. (It is common pratice to store secret keys in environment variables rather than hardcoding them in ode, to prevent unauthorized acccess to the key).
        //So, when this code runs, it creates a JWT that contains the user's ID, and signs it using the scret key stored in the "JWT_SECRET" environment variable. You want your JWT_SECRET to be hard to guess so that it doesn't get compromised. The resulting JWT is then stored in the "token" variable. 
        delete user.password;                                           //The purpose of this statement is to remove the user's password from the response sent back to the client after a successful login. 
        res.status(200).json({token,user})                              //send this response where we pass in 'token' and 'user'   
    }catch(err){
        res.status(500).json({error:err.message})
    }
}